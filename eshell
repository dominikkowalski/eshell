#!/usr/bin/env python
# -*- coding: utf-8 -*-
# -----------------
# title            : eShell
# description      : Elasticsearch API avaiable via Python interactive shell.
# author           : Patryk Krawaczy≈Ñski
# update date      : 02.02.2017
# version          : 0.5.1.2
# license          : Apache License (2.0)
# usage            : ./eshell [es master ip | es master hostname]
# python version   : 3.5.3
# required modules : requests 2.13.0 (http://docs.python-requests.org/en/master/)
#                  : elasticsearch 5.1.0 (http://elasticsearch-py.readthedocs.org/en/master/)
# notes            : https://github.com/nfsec/eshell
# -----------------

import cmd
import os
import re
import socket
import subprocess
import sys
import json
import elasticsearch
import requests
import readline
import operator


# Helpers
def error(message):
    """
    Print error message and exit with status 2.
    """
    print("Error: {0}".format(message))
    sys.exit(2)


def check_ip(ip):
    """
    Check if IP address is valid one.
    """
    try:
        socket.inet_aton(ip)
        return True
    except socket.error:
        return False


def check_hostname(hostname):
    """
    Check if DNS address is valid one.
    """
    try:
        socket.gethostbyname(hostname)
        return True
    except socket.error:
        return False


def less(text):
    try:
        pager = subprocess.Popen(["less", "-F", "-R", "-S", "-X", "-K", "-N"], stdin=subprocess.PIPE, stdout=sys.stdout)
        for line in text:
            pager.stdin.write(line.encode("utf-8"))
        pager.communicate()[0]
        pager.stdin.close()
        pager.wait()
    except IOError:
        print("Exiting...")
    except KeyboardInterrupt:
        print("Exiting...")


def isopen(ip, port):
    """
    Check if IP address have open port.
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1)
    try:
        s.connect((ip, port))
        s.settimeout(None)
        s.shutdown(2)
        print("Connected to: {0} on port: {1}".format(str(ip), str(port)))
        return True
    except socket.error as e:
        print("Problem with connection to: {0} on port: {1}. Error code:".format(str(ip), str(port)), e)
        return False


def commandlist(subcommand):
    commands = []
    for i in dir(subcommand):
        if i.startswith("do_"):
            commands.append(i.replace("do_", ""))
    return commands


def pretty_print(dictionary, indent=0):
    """
    Pretty print all the complexities.
    """
    for k, v in sorted(dictionary.items()):
        if type(v) == dict:
            if len(v) == 0:
                print(" " * indent, str(k) + ": {empty}")
            else:
                print(" " * indent, str(k) + ": ")
                pretty_print(v, indent + len(k) + 1)
        elif type(v) == list:
            if len(v) == 0:
                print(" " * indent, str(k) + ": [empty]")
            elif type(v[0]) == dict:
                print(" " * indent, str(k) + ": ")
                for x in v:
                    pretty_print(x, indent + len(k) + 1)
            else:
                print(" " * indent, str(k) + ": " + str.join(", ", v))
        else:
            print(" " * indent, str(k) + ": " + str(v))


# Autocomplete functions
def indexlist():
    indices = []
    for i in es.cat.indices(h="index").split("\n"):
        if i:
            indices.append(i.replace(" ", ""))
    return indices


def nodelist():
    nodes = []
    for i in es.cat.nodes(h="name").split("\n"):
        if i:
            nodes.append(i)
    return nodes


# Colors for terminal
class BColors:
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


# Elasticsearch console
class ES(cmd.Cmd):
    intro = "{0}\n### Welcome to Elastic Shell console!\n### For more information, type \"help\" or \"?\".\n{1}".format(
        BColors.BOLD, BColors.ENDC)
    prompt = "es:~$ "
    ruler = "-"
    doc_header = "Available commands (type: help <command>):"

    def default(self, line):
        """
        Called on an input line when the command prefix is not recognized.
        In that case we execute the line as Python code.
        """
        try:
            exec(line) in self._locals, self._globals
        except NameError:
            print("Command {0} not found.".format(line))
        except SyntaxError:
            print("Command not found or invalid syntax.")
        except KeyboardInterrupt:
            print("Detected Ctrl+D. Exiting...")
        except Exception as e:
            print("{0} : {1}".format(e.__class__, e))

    def preloop(self):
        """
        Initialization before prompting user for commands.
        """
        cmd.Cmd.preloop(self)
        self._history = []
        self._locals = {}
        self._globals = {}

    def precmd(self, line):
        """
        This method is called after the line has been input but before
        it has been interpreted. If you want to modifdy the input line
        before execution (for example, variable substitution) do it here.
        """
        self._history += [line.strip()]
        return line

    def postloop(self):
        """
        Take care of any unfinished business.
        """
        cmd.Cmd.postloop(self)
        print("Exiting...")

    def postcmd(self, stop, line):
        """
        If you want to stop the console, return something that evaluates to true.
        If you want to do some post command processing, do it here.
        """
        return stop

    def emptyline(self):
        """
        Do nothing on empty line input.
        """
        pass

    def do_prompt(self, args):
        """
        Change console prompt.
        $ prompt [new prompt] - set new prompt.
        """
        self.prompt = "{0}:~$ ".format(args)

    def do_help(self, args):
        """
        Get help on commands:
        'help' or '?' with no arguments prints a list of commands for which help is available
        'help <command>' or '? <command>' gives help on <command>
        """
        cmd.Cmd.do_help(self, args)

    def do_history(self, args):
        """
        Print a list of commands that have been entered into console.
        """
        print(self._history)

    def do_clear(self, args):
        """
        Clear the screen.
        """
        os.system("clear")

    def do_shell(self, line):
        """
        Pass command to a system shell when line begins with '!'
        """
        print("Running shell command: {0}\n".format(line))
        sub_cmd = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE)
        output = sub_cmd.communicate()[0].decode("utf-8")
        print(output)
        self.last_output = output

    def do_echo(self, line):
        """
        Print the input, replacing '$out' with the output of the last shell command.
        """
        print(line.replace("$out", self.last_output))

    def do_quit(self, args):
        """
        Quits from the console.
        """
        print("Quitting...")
        sys.exit(0)

    def do_exit(self, args):
        """
        Exits from the console.
        """
        print("Exiting...")
        sys.exit(0)

    def do_EOF(self, line):
        """
        Exit on system end of file character (Ctrl+D).
        """
        return True

    def do_show(self, args):
        """
        Enter to cluster information submenu.
        """
        show_cli = Show()
        show_cli.cmdloop()

    def do_exec(self, args):
        """
        Enter to cluster execution submenu.
        """
        exec_cli = Exec()
        exec_cli.cmdloop()


class Show(cmd.Cmd):
    intro = "\n{0}### Entering to cluster information menu!\n### For more information, type \"help\" or \"?\".\n{1}". \
        format(BColors.BOLD, BColors.ENDC)
    prompt = "es:show~$ "
    ruler = "-"
    doc_header = "Available commands (type: help <command>):"

    def default(self, line):
        """
        Called on an input line when the command prefix is not recognized.
        In that case we execute the line as Python code.
        """
        try:
            exec(line) in self._locals, self._globals
        except NameError:
            print("Command {0} not found.".format(line))
        except SyntaxError:
            print("Command not found or invalid syntax.")
        except KeyboardInterrupt:
            print("Detected Ctrl+D. Exiting...")
        except Exception as e:
            print("{0} : {1}".format(e.__class__, e))

    def preloop(self):
        """
        Initialization before prompting user for commands.
        """
        cmd.Cmd.preloop(self)
        self._history = []
        self._locals = {}
        self._globals = {}

    def precmd(self, line):
        """
        This method is called after the line has been input but before
        it has been interpreted. If you want to modifdy the input line
        before execution (for example, variable substitution) do it here.
        """
        self._history += [line.strip()]
        return line

    def postloop(self):
        """
        Take care of any unfinished business.
        """
        cmd.Cmd.postloop(self)
        print("Exiting...")

    def postcmd(self, stop, line):
        """
        If you want to stop the console, return something that evaluates to true.
        If you want to do some post command processing, do it here.
        """
        return stop

    def emptyline(self):
        """
        Do nothing on empty line input.
        """
        pass

    def do_prompt(self, args):
        """
        Change console prompt.
        $ prompt [new prompt] - set new prompt.
        """
        self.prompt = "{0}:~$ ".format(args)

    def do_help(self, args):
        """
        Get help on commands:
        'help' or '?' with no arguments prints a list of commands for which help is available
        'help <command>' or '? <command>' gives help on <command>
        """
        cmd.Cmd.do_help(self, args)

    def do_history(self, args):
        """
        Print a list of commands that have been entered into console.
        """
        print(self._history)

    def do_clear(self, args):
        """
        Clear the screen.
        """
        os.system("clear")

    def do_shell(self, line):
        """
        Pass command to a system shell when line begins with '!'
        """
        print("Running shell command: {0}\n".format(line))
        sub_cmd = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE)
        output = sub_cmd.communicate()[0].decode("utf-8")
        print(output)
        self.last_output = output

    def do_echo(self, line):
        """
        Print the input, replacing '$out' with the output of the last shell command.
        """
        print(line.replace("$out", self.last_output))

    def do_quit(self, args):
        """
        Quits from the console.
        """
        print("Quitting...")
        sys.exit(0)

    def do_exit(self, args):
        """
        Exits from the console.
        """
        print("Exiting...")
        sys.exit(0)

    def do_EOF(self, line):
        """
        Exit on system end of file character (Ctrl+D).
        """
        return True

    def do_exec(self, line):
        """
        Execute command in cluster execution menu.
        """
        Exec().onecmd(line)

    def complete_exec(self, text, line, begidx, endidx):
        return [i for i in commandlist(Exec()) if i.startswith(text)]

    # Elasticsearch cluster
    def do_cluster_allocation(self, args):
        """
        The purpose of the cluster allocation explain API is to provide explanations for shard allocations in the
        cluster. For unassigned shards, the explain API provides an explanation for why the shard is unassigned.
        $ cluster_allocation - explain the first unassigned shard.
        $ cluster_allocation .kibana 0 true - specify the index and shard id of the shard you would like an explanation
          for, as well as the primary flag to indicate whether to explain the primary shard for the given shard id or
          one of its replica shards. These three request parameters are required.
        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please provide index name, shard id and true or false if primary.")
                print()
            else:
                try:
                    showme = '{{ "index": "{0}", "shard": {1}, "primary": {2} }}'.format(str(parms[0]), str(parms[1]),
                                                                                         str(parms[2]))
                    print()
                    pretty_print(es.cluster.allocation_explain(body=showme), indent=2)
                    print()
                except Exception as e:
                    print(e)
        else:
            try:
                print()
                pretty_print(es.cluster.allocation_explain(include_disk_info=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def do_cluster_templates(self, args):
        """
        The cluster_templates command provides information about existing templates.
        $ cluster_templates [template name] - show template information in json format.
        $ cluster_templates - show all templates in cluster.
        """
        if args:
            try:
                print()
                print(json.dumps(es.indices.get_template(name=args), indent=4))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                print(es.cat.templates(v=True, s="name"))
            except Exception as e:
                print(e)

    def do_cluster_repositories(self, args):
        """
        The repositories command shows the snapshot repositories registered in the cluster.
        """
        try:
            print()
            print(es.cat.repositories(v=True, s="id"))
        except Exception as e:
            print(e)

    def do_cluster_snapshots(self, args):
        """
        The cluster_snapshots command shows all snapshots that belong to a specific repository.
        $ cluster_snapshots [repository name] - show information about each snapshot in repository.
        """
        if args:
            try:
                print()
                print(es.cat.snapshots(repository=args, ignore_unavailable=True, v=True, s="id"))
            except Exception as e:
                print(e)
        else:
            print()
            print("Please provide name of repository to show its snapshots. ")
            print("To find a list of available repositories to query, the command 'cluster_repositories' can be used.")
            print()

    def do_cluster_ping(self, args):
        """
        Returns 'UP' if the cluster is up, 'DOWN' otherwise.
        """
        try:
            if es.ping():
                print("\nUP!\n")
            else:
                print("\nDOWN!\n")
        except Exception as e:
            print(e)

    def do_cluster_info(self, args):
        """
        Get the basic info from the current cluster.
        """
        try:
            print()
            pretty_print(es.info(), indent=2)
            print()
        except Exception as e:
            print(e)

    def do_cluster_master(self, args):
        """
        Displays the master‚Äôs node ID, bound IP address, and node name.
        """
        try:
            print()
            print(es.cat.master(v=True))
        except Exception as e:
            print(e)

    def do_cluster_health(self, args):
        """
        Get a very simple status on the health of the cluster.
        $ cluster_health - show cluster health.
        $ cluster_health table - one-line representation of the same information from cluster_health.
        """
        try:
            if args == "table":
                print()
                print(es.cat.health(v=True))
            else:
                print()
                pretty_print(es.cluster.health(level="cluster"), indent=2)
                print()
        except Exception as e:
            print(e)

    def do_cluster_tasks(self, args):
        """
        Show all pending cluster tasks which have not yet been executed.
        $ cluster_tasks urgent - show urgent tasks.
        $ cluster_tasks high - show high tasks.
        $ cluster_tasks normal - show normarl tasks.
        $ cluster_tasks - show all tasks (default).
        """
        try:
            task_list = es.cat.pending_tasks(v=True)
            if args in ["urgent", "high", "normal"]:
                print()
                print(task_list.split("\n")[0])
                for line in task_list.split("\n"):
                    if args.upper() in line:
                        print(line)
                print()
            else:
                print()
                less(es.cat.pending_tasks(v=True))
                print()
        except Exception as e:
            print(e)

    def do_cluster_tasks_stats(self, args):
        """Show cluster tasks statistics."""
        task_list = requests.get("{0}/_cat/pending_tasks?v=True".format(host))
        ustats = re.compile("URGENT")
        umatch = ustats.findall(task_list.content.decode("utf-8"))
        hstats = re.compile("HIGH")
        hmatch = hstats.findall(task_list.content.decode("utf-8"))
        nstats = re.compile("NORMAL")
        nmatch = nstats.findall(task_list.content.decode("utf-8"))
        print("Tasks statistics: URGENT: {0} HIGH: {1} NORMAL: {2}".format(str(len(umatch)), str(len(hmatch)), str(
            len(nmatch))))

    def do_cluster_settings(self, args):
        """
        Get current cluster settings.
        $ cluster_settings with_defaults - get cluster default settings.
        $ cluster_settings - get cluster custom settings (default).
        """
        try:
            if args == "with_defaults":
                print()
                pretty_print(es.cluster.get_settings(flat_settings=True, include_defaults=True), indent=2)
                print()
            else:
                print()
                pretty_print(es.cluster.get_settings(flat_settings=True), indent=2)
                print()
        except Exception as e:
            print(e)

    def do_cluster_stats(self, args):
        """
        The Cluster stats allows to retrieve statistics from a cluster wide perspective.
        """
        try:
            print()
            pretty = es.cluster.stats(human=True)
            print("cluster_name: {0}".format(str(pretty["cluster_name"])))
            print("status: {0}".format(str(pretty["status"])))
            print("timestamp: {0}".format(str(pretty["timestamp"])))
            print("_nodes")
            pretty_print(pretty["_nodes"], indent=7)
            print("nodes:")
            pretty_print(pretty["nodes"], indent=6)
            print("indices:")
            pretty_print(pretty["indices"], indent=8)
            print()
        except Exception as e:
            print(e)

    def do_cluster_version(self, args):
        """
        Shows the cluster state version.
        """
        try:
            print()
            pretty = es.cluster.state(metric="version", flat_settings=True)
            pretty_print(pretty, indent=2)
            print()
        except Exception as e:
            print(e)

    def do_cluster_nodes(self, args):
        """
        Shows the cluster nodes part of the response.
        """
        try:
            print()
            pretty = es.cluster.state(metric="nodes", flat_settings=True)
            pretty_print(pretty, indent=2)
            print()
        except Exception as e:
            print(e)

    def do_cluster_blocks(self, args):
        """
        Shows the cluster blocks part of the response.
        """
        try:
            print()
            pretty = es.cluster.state(metric="blocks", flat_settings=True)
            pretty_print(pretty, indent=2)
            print()
        except Exception as e:
            print(e)

    # Elasticsearch indices
    def do_indices_mapping(self, args):
        """
        Retrieve mapping definition of index or index/type.
        - indices_mapping [index name] - show <index> mapping.
        """
        if args:
            try:
                print()
                pretty = es.indices.get_mapping(index=args)
                print(json.dumps(pretty, indent=4))
                print()
            except Exception as e:
                print(e)
        else:
            print("Please provide index name.")

    def complete_indices_mapping(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_docs(self, args):
        """
        The number of docs / deleted docs (docs not yet merged out). Note, affected by refreshing the index.
        $ indices_stats_docs [index name] - show number of docs for <index>.
        $ indices_stats_docs - show number of docs for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="docs", human=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="docs", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_docs(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_store(self, args):
        """
        Show the size of the indices.
        $ indices_stats_store [index name] - show size of <index>.
        $ indices_stats_store - show size of all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="store", human=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="store", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_store(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_indexing(self, args):
        """
        Show indexing statistics.
        $ indices_stats_indexing [index name] - show indexing stats for <index>.
        $ indices_stats_indexing - show indexing stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="indexing", human=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="indexing", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_indexing(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_get(self, args):
        """
        Get statistics, including missing stats.
        $ indices_stats_get [index name] - show get stats for <index>.
        $ indices_stats_get - show get stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="get", human=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="get", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_get(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_search(self, args):
        """
        Search statistics including suggest statistics.
        $ indices_stats_search [index name] - show search stats for <index>.
        $ indices_stats_search - show search stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="search", human=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="search", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_search(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_segments(self, args):
        """
        Retrieve the memory use of the open segments.
        $ indices_stats_segments [index name] - show open segments stats for <index>.
        $ indices_stats_segments - show open segments stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="segments", human=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="segments", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_segments(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_completion(self, args):
        """
        Show completion suggest statistics.
        $ indices_stats_completion [index name] - show completion suggest stats for <index>.
        $ indices_stats_completion - show completion suggest stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="completion", human=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="completion", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_completion(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_fielddata(self, args):
        """
        Show fielddata statistics.
        $ indices_stats_fielddata [index name] - show fielddata stats for <index>.
        $ indices_stats_fielddata - show fielddata stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="fielddata", human=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="fielddata", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_fielddata(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_flush(self, args):
        """
        Show flush statistics.
        $ indices_stats_flush [index name] - show flush stats for <index>.
        $ indices_stats_flush - show flush stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="flush", human=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="flush", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_flush(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_merge(self, args):
        """
        Show merge statistics.
        $ indices_stats_merge [index name] - show merge stats for <index>.
        $ indices_stats_merge - show merge stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="merge", human=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="merge", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_merge(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_request_cache(self, args):
        """
        Show request cache statistics.
        $ indices_stats_request_cache [index name] - show request cache stats for <index>.
        $ indices_stats_request_cache - show request cache stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="request_cache", human=True),
                             indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="request_cache", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_request_cache(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_refresh(self, args):
        """
        Show refresh statistics.
        $ indices_stats_refresh [index name] - show refresh stats for <index>.
        $ indices_stats_refresh - show refresh stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="refresh", human=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="refresh", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_refresh(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_warmer(self, args):
        """
        Show warmer statistics.
        $ indices_stats_warmer [index name] - show warmer stats for <index>.
        $ indices_stats_warmer - show warmer stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="warmer", human=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="warmer", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_warmer(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_translog(self, args):
        """
        Show translog statistics.
        $ indices_stats_translog [index name] - show translog stats for <index>.
        $ indices_stats_translog - show translog stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="translog", human=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="translog", human=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_stats_translog(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_size(self, args):
        """
        Show indices size statistics.
        """
        try:
            index_list = es.cat.indices(h="index,pri.store.size", bytes="b")
            index_temp = []
            for text_line in index_list.split():
                index_temp.append(text_line)
            index_dict = dict(index_temp[i:i + 2] for i in range(0, len(index_temp), 2))
            index_dict = {str(k): int(v) for k, v in index_dict.items()}
            index_sort = sorted(index_dict.items(), key=operator.itemgetter(1))
            almost_1mb = []
            almost_10mb = []
            almost_100mb = []
            almost_1gb = []
            almost_10gb = []
            almost_100gb = []
            almost_other = []
            for item in index_sort:
                if item[1] <= 1000000:
                    almost_1mb.append(item)
                elif item[1] <= 10000000:
                    almost_10mb.append(item)
                elif item[1] <= 100000000:
                    almost_100mb.append(item)
                elif item[1] <= 1000000000:
                    almost_1gb.append(item)
                elif item[1] <= 10000000000:
                    almost_10gb.append(item)
                elif item[1] <= 100000000000:
                    almost_100gb.append(item)
                elif item[1] >= 100000000000:
                    almost_other.append(item)
            print()
            print(
                "i <= 1.MB: {0} | i <= 10.MB: {1} | i <= 100.MB: {2} | i <= 1.GB: {3} | i <= 10.GB: {4} | i <= 100.GB: {5} | i >= 100.GB: {6}".format(
                    str(len(almost_1mb)), str(
                        len(almost_10mb)), str(len(almost_100mb)), str(
                        len(almost_1gb)), str(len(almost_10gb)), str(
                        len(almost_100gb)), str(len(almost_other))))
            print()
        except Exception as e:
            print(e)

    def do_indices_settings(self, args):
        """
        Retrieve settings for one or more (or all) indices.
        - indices_settings [index name] - show settings for <index>.
        - indices_settings - show settings for all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.indices.get_settings(index=args, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.indices.get_settings(flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_settings(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_status(self, args):
        """
        Show indices state statistics.
        """
        try:
            index_list = es.cat.indices(v=True, h="health")
            rstats = re.compile("red")
            rmatch = rstats.findall(index_list)
            ystats = re.compile("yellow")
            ymatch = ystats.findall(index_list)
            gstats = re.compile("green")
            gmatch = gstats.findall(index_list)
            print("Indices states: RED: {0} YELLOW: {1} GREEN: {2}".format(str(len(rmatch)), str(len(ymatch)), str(
                len(gmatch))))
        except Exception as e:
            print(e)

    def do_indices_exists(self, args):
        """
        Return a information indicating whether given index exists.
        $ indices_exists [index name] - a name of index to check (default).
        """
        if args:
            print()
            try:
                if es.indices.exists(index=args):
                    print("{0} exists.".format(args))
                    print()
                else:
                    print("{0} don't exists".format(args))
                    print()
            except Exception as e:
                print(e)
        else:
            print()
            print("No indices specified.")
            print()

    def complete_indices_exists(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_segments(self, args):
        """
        The segments command is the detailed view of Lucene segments per index.
        $ indices_segments [index name] - show segments of the index.
        $ indices_segments  - show segments of all indices (default).
        """
        if args:
            try:
                print()
                less(es.cat.segments(index=args, v=True, s="index"))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                less(es.cat.segments(v=True, s="index"))
                print()
            except Exception as e:
                print(e)

    def complete_indices_segments(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_metadata(self, args):
        """
        Shows the indices metadata part of the response.
        If you supply a comma separated list of indices, the returned
        output will only contain the indices listed.
        $ indices_metadata [index name] - show metadata of index.
        $ indices_metadata - show metadata of all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.cluster.state(metric="metadata", index=args, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.cluster.state(metric="metadata", flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_metadata(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices(self, args):
        """
         The indices command provides a cross-section of each index.
         $ indices [index name] - show information about index.
         $ indices - show information about all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.indices(s="index", v=True, index=args))
            except Exception as e:
                print(e)
        else:
            try:
                print()
                less(es.cat.indices(s="index", v=True))
                print()
            except Exception as e:
                print(e)

    def complete_indices(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_green(self, args):
        """
        The indices_green command provides a cross-section of each index in green health status.
        $ indices [index name] - show information about index.
        $ indices - show information about all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.indices(s="index", v=True, index=args, health="green"))
            except Exception as e:
                print(e)
        else:
            try:
                print()
                print(es.cat.indices(s="index", v=True, health="green"))
            except Exception as e:
                print(e)

    def complete_indices_green(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_yellow(self, args):
        """
        The indices_yellow command provides a cross-section of each index in yellow health status.
        $ indices [index name] - show information about index.
        $ indices - show information about all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.indices(s="index", v=True, index=args, health="yellow"))
            except Exception as e:
                print(e)
        else:
            try:
                print()
                print(es.cat.indices(s="index", v=True, health="yellow"))
            except Exception as e:
                print(e)

    def complete_indices_yellow(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_red(self, args):
        """
        The indices_red command provides a cross-section of each index in red health status.
        $ indices [index name] - show information about index.
        $ indices - show information about all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.indices(s="index", v=True, index=args, health="red"))
            except Exception as e:
                print(e)
        else:
            try:
                print()
                print(es.cat.indices(s="index", v=True, health="red"))
            except Exception as e:
                print(e)

    def complete_indices_red(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_aliases(self, args):
        """
        Shows information about currently configured aliases to indices including filter and routing infos.
        $ indices_aliases [alias name] - alias name to return from aliases.
        $ indices_aliases - show all aliases (default).
        """
        if args:
            try:
                print()
                print(es.cat.aliases(name=args, v=True))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                print(es.cat.aliases(s="alias", v=True))
                print()
            except Exception as e:
                print(e)

    def do_indices_documents(self, args):
        """
        Count provides quick access to the document count of the entire cluster, or individual indices.
        The document count indicates the number of live documents and does not include deleted documents
        which have not yet been cleaned up by the merge process.
        $ indices_documents [index name] - document count in index.
        $ indices_documents - document count for all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.count(index=args, v=True))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                print(es.cat.count(v=True))
                print()
            except Exception as e:
                print(e)

    def complete_indices_documents(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    # TODO
    # def do_indices_completion(self, args):
    #    """
    #    """
    #    print()
    #    pretty_print(es.nodes.stats(metric="indices", level="indices", index_metric="completion"), indent=2)
    #    print()

    def complete_indices_completion(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_routing_table(self, args):
        """
        Shows the indices routing_table part of the response.
        If you supply a comma separated list of indices, the returned
        output will only contain the indices listed.
        $ indices_routing_table [index name] - show routing_table of index.
        $ indices_routing_table - show routing_table of all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.cluster.state(metric="routing_table", index=args, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.cluster.state(metric="routing_table", flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_routing_table(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_health(self, args):
        """
        Get a very simple status on the health of the indices.
        $ indices_health [index name] - show health of index.
        $ indices_health - show health of all indices (default).
        """
        if args:
            try:
                print("ok")
                pretty_print(es.cluster.health(level="indices", index=args), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print("ee")
                pretty_print(es.cluster.health(level="indices"), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_indices_health(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    # Elasticsearch shards
    def do_shards(self, args):
        """
        The shards command is the detailed view of what nodes contain which shards.
        $ shards [index name] - show shards of index.
        $ shards - show shards of all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.shards(index=args, v=True))
            except Exception as e:
                print(e)
        else:
            try:
                print()
                less(es.cat.shards(v=True))
                print()
            except Exception as e:
                print(e)

    def complete_shards(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_unassigned(self, args):
        """
        List unassigned shards.
        """
        shard_list = es.cat.shards(v=True)
        print()
        print(shard_list.split("\n")[0])
        for line in shard_list.split("\n"):
            if "UNASSIGNED" in line:
                print(line)
        print()

    def do_shards_relocating(self, args):
        """
        List relocating shards.
        """
        shard_list = es.cat.shards(v=True)
        print()
        print(shard_list.split("\n")[0])
        for line in shard_list.split("\n"):
            if "RELOCATING" in line:
                print(line)
        print()

    def do_shards_initializing(self, args):
        """
        List initializing shards.
        """
        shard_list = es.cat.shards(v=True)
        print()
        print(shard_list.split("\n")[0])
        for line in shard_list.split("\n"):
            if "INITIALIZING" in line:
                print(line)
        print()

    def do_shards_started(self, args):
        """
        List started shards.
        """
        shard_list = es.cat.shards(v=True)
        print()
        print(shard_list.split("\n")[0])
        for line in shard_list.split("\n"):
            if "STARTED" in line:
                print(line)
        print()

    def do_shards_recovery(self, args):
        """
        Recovery is a view of shard replication.
        $ shards_recovery [index name] - show recovery status of the index.
        $ shards_recovery - show recovery status of all indices (default).

          index                  | idx | index name
          shard                  | sh  | shard name
          time                   | ti  | recovery time
          type                   | ty    | recovery type
          stage                  | st    | recovery stage
          source_host            | shost | source host
          source_node            | snode | source node name
          target_host            | thost | target host
          target_node            | tnode | target node name
          repository             | rep   | repository
          snapshot               | snap  | snapshot
          files                  | f     | number of files to recover
          files_recovered        | fr    | files recovered
          files_percent          | fp    | percent of files recovered
          files_total            | tf    | total number of files
          bytes                  | b     | number of bytes to recover
          bytes_recovered        | br    | bytes recovered
          bytes_percent          | bp    | percent of bytes recovered
          bytes_total            | tb    | total number of bytes
          translog_ops           | to    | number of translog ops to recover
          translog_ops_recovered | tor   | translog ops recovered
          translog_ops_percent   | top   | percent of translog ops recovered
        """
        if args:
            try:
                print()
                print(es.cat.recovery(index=args, v=True, s="index",
                                      h="idx,sh,ti,ty,st,shost,snode,thost,tnode,rep,snap,f,fr,fp,tf,b,br,bp,tb,to,tor,top"))
            except Exception as e:
                print(e)
        else:
            try:
                print()
                less(es.cat.recovery(v=True, s="index",
                                     h="idx,sh,ti,ty,st,shost,snode,thost,tnode,rep,snap,f,fr,fp,tf,b,br,bp,tb,to,tor,top"))
                print()
            except Exception as e:
                print(e)

    def complete_shards_recovery(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_health(self, args):
        """
        Get a very simple status on the health of the indices shards.
        $ indices_health [index name] - show health of index shards.
        $ indices_health - show health of shards in all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.cluster.health(level="shards", index=args), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.cluster.health(level="shards"), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_shards_health(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

        ### ???
        # Elasticsearch nodes info commands
        # def do_nodes_hot_threads(self, args):
        # params = args.split()

    #    print(es.nodes.hot_threads())

    # Elasticsearch nodes
    def do_nodes_plugins(self, args):
        """
        The plugins command provides a view per nodes of running plugins.
        """
        try:
            print()
            print(es.cat.plugins(v=True, s="name"))
        except Exception as e:
            print(e)

    def do_nodes_settings(self, args):
        """
        Retrieves information about node(s) settings in the cluster.
        $ nodes_settings [node_id/name] - show node settings.
        $ node_settings - show all the nodes settings in the cluster (default).
          - build_hash - sort of the last git commit in this release.
          - host - the node's host name.
          - http_address - host and port where primary HTTP connections are accepted.
          - ip - the node's ip address.
          - name - the nodes name.
          - transport_address - host and port where transport HTTP connections are accepted.
          - version - elasticsearch version running on this node.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="settings", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="settings", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_nodes_settings(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_os(self, args):
        """
        Retrieve node(s) information that concern the operating system.
        $ nodes_info_os [node_id/name] - show node os information.
        $ nodes_info_os - show os information for all the nodes (default).
          - os.refresh_interval_in_millis - refresh interval for the OS statistics.
          - os.name - name of the operating system (Linux / Windows / Mac OS X).
          - os.arch - name of the JVM architecture (amd64, x86).
          - os.version - version of the operating system.
          - os.available_processors - number of processors available to the Java virtual machine.
          - os.allocated_processors - the number of processors actually used to calculate thread
            pool size. This number can be set with the "processors" setting of a node and defaults
            to the number of processors reported by the OS. In both cases this number will never be
            larger than 32.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="os", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="os", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_nodes_info_os(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_process(self, args):
        """
        Retrieve node(s) information that concern the current running ElasticSearch process.
        $ node_info_process [node_id/name] - show node ES process information.
        $ node_info_process - show ES process information for all the nodes (default).
          - process.refresh_intervel_in_millis - refresh interval for the process statistics.
          - process.id - process identifier (PID).
          - process.mlockall - indicates if the process address space has been successfully locked in memory.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="process", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="process", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_nodes_info_process(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_jvm(self, args):
        """

        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="jvm", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="jvm", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_nodes_info_jvm(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_thread_pool(self, args):
        """

        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="thread_pool", human=True, flat_settings=True),
                             indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="thread_pool", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_nodes_info_thread_pool(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_transport(self, args):
        """

        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="transport", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="transport", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_nodes_info_transport(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_http(self, args):
        """

        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="http", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="http", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_nodes_info_http(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_plugins(self, args):
        """
        Result will contain details about the loaded plugins per node.
        $ node_info_plugins [node_id/name] - show node ES plugins information.
        $ node_info_plugins - show ES plugins information for all the nodes (default).
          - plugins.name - plugin name.
          - plugins.description - plugin description if any.
          - plugins.site - true if the plugin is a site plugin.
          - plugins.jvm - true if plugin is a plugin running in the JVM.
          - plugins.url - URL if the plugin is a site plugin.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="plugins", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="plugins", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_nodes_info_plugins(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_ingest(self, args):
        """
        Result will contain details about the available processors per node.
        $ node_info_ingest [node_id/name] - show node ES ingest information.
        $ node_info_ingest - show ES ingest information for all the nodes (default).
          - processors.type - the processor type.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="ingest", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="ingest", human=True, flat_settings=True), indent=2)
                print()
            except Exception as e:
                print(e)

    def complete_nodes_info_ingest(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_indexing_buffer(self, args):
        """
        Result will contain details about heap used for indexing process.
        $ node_info_indexing_buffer [node_id/name] - show node ES indexing heap information.
        $ node_info_indexing_buffer - show ES indexing heap information for all the nodes (default).
          - total_indexing_buffer - total heap allowed to be used to hold recently indexed documents before
            they must be written do disk. This size is a shared pool across all shards on this node, and is
            controlled by Indexing Buffer settings (indices.memory.index_buffer_size).
          - total_indexing_buffer_in_bytes - same as total_indexing_buffer but expressed in bytes.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="indices", human=True, flat_settings=True))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="indices", human=True, flat_settings=True))
                print()
            except Exception as e:
                print(e)

    def complete_nodes_info_indexing_buffer(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_indices(self, args):
        """
        Show indices stats about size, document count, indexing and deletion times, search times,
        field cache size, merges and flushes.
        $ node_stats_indices [node_id/name] - show node ES indices stats.
        $ node_stats_indices - show ES indices stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="indices", human=True, level="node"))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="indices", human=True, level="node"))
                print()
            except Exception as e:
                print(e)

    def complete_nodes_stats_indices(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_fs(self, args):
        """
        Show file system information, data path, free disk space, read/write stats.
        $ nodes_stats_fs [node_id/name] - show node ES fs stats.
        $ nodes_stats_fs - show node ES fs stats for all the nodes (default).
          - fs.timestamp - last time the file stores statistics have been refreshed.
          - fs.total.total_in_bytes - total size (in bytes) of all file stores.
          - fs.total.free_in_bytes - total number of unallocated bytes in all file stores.
          - fs.total.available_in_bytes - total number of bytes available to this Java virtual machine on all
            file stores.
          - fs.data - list of all file stores.
          - fs.data.path - path to the file store.
          - fs.data.mount - mount point of the file store (ex: /dev/sda2)
          - fs.data.type - type of the file store (ex: ext4)
          - fs.data.total_in_bytes - total size (in bytes) of the file store.
          - fs.data.free_in_bytes - total number of unallocated bytes in the file store.
          - fs.data.available_in_bytes - total number of bytes available to this Java virtual machine on this
            file store.
          - fs.data.spins - indicates if the store is backed by spinning storage.
            null means we cloud not determine it.
            true means the device possible spins.
            false means it does not (ex: solid-state disk)
          - fs.io_stats.devices - array of disk metrics for each device that is backing an Elasticsearch data path.
            These disk metrics are probed periodically and averages between the last probe and the current probe are
            computed.
          - fs.io_stats.devices.device_name - the Linux device name.
          - fs.io_stats.devices.operations - the total number of read and write operations for the device completed
            since starting Elasticsearch.
          - fs.io_stats.devices.read_operations - the total number of read operations for the device completed since
            starting Elasticsearch.
          - fs.io_stats.devices.write_operations - the total number of write operations for the device completed since
            starting Elasticsearch.
          - fs.io_stats.devices.read_kilobytes - the total number of kilobytes read for the device since starting
            Elasticsearch.
          - fs.io_stats.devices.write_kilobytes - the total number of kilobytes written for the device since starting
            Elasticsearch.
          - fs.io_stats.operations - the total number of read and write operations across all devices used by
            Elasticsearch completed since starting Elasticsearch.
          - fs.io_stats.read_operations - the total number of read operations for across all devices used by
            Elasticsearch completed since starting Elasticsearch.
          - fs.io_stats.write_operations - the total number of write operations across all devices used by
            Elasticsearch completed since starting Elasticsearch.
          - fs.io_stats.read_kilobytes - the total number of kilobytes read across all devices used by Elasticsearch
            since starting Elasticsearch.
          - fs.io_stats.write_kilobytes - the total number of kilobytes written across all devices used by Elasticsearch
            since starting Elasticsearch.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="fs", human=True, level="node"))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="fs", human=True, level="node"))
                print()
            except Exception as e:
                print(e)

    def complete_nodes_stats_fs(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_http(self, args):
        """
        Show HTTP connection information.
        $ node_stats_http [node_id/name] - show node ES HTTP stats.
        $ node_stats_http - show ES HTTP stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="http", human=True, level="node"))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="http", human=True, level="node"))
                print()
            except Exception as e:
                print(e)

    def complete_nodes_stats_http(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_jvm(self, args):
        """
        Show JVM stats, memory pool information, garbage collection, buffer pools, number of loaded/unloaded classes.
        $ node_stats_jvm [node_id/name] - show node ES JVM stats.
        $ node_stats_jvm - show ES JVM stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="jvm", human=True, level="node"))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="jvm", human=True, level="node"))
                print()
            except Exception as e:
                print(e)

    def complete_nodes_stats_jvm(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_os(self, args):
        """
        Show operating system stats, load average, mem, swap.
        $ node_stats_os [node_id/name] - show node ES OS stats.
        $ node_stats_os - show ES OS stats for all the nodes (default).
          - os.timestamp - last time the operating system statistics have been refreshed.
          - os.cpu.percent - recent CPU usage for the whole system, or -1 if not supported.
          - os.cpu.load_average.1m - one-minute load average on the system (field is not present if one-minute load
            average is not available).
          - os.cpu.load_average.5m - five-minute load average on the system (field is not present if five-minute
            load average is not available).
          - os.cpu.load_average.15m - fifteen-minute load average on the system (field is not present if fifteen-minute
            load average is not available).
          - os.mem.total_in_bytes - total amount of physical memory in bytes.
          - os.mem.free_in_bytes - amount of free physical memory in bytes.
          - os.mem.free_percent - percentage of free memory.
          - os.mem.used_in_bytes - amount of used physical memory in bytes.
          - os.mem.used_percent - percentage of used memory.
          - os.swap.total_in_bytes - total amount of swap space in bytes.
          - os.swap.free_in_bytes - amount of free swap space in bytes.
          - os.swap.used_in_bytes - amount of used swap space in bytes.
          - os.cgroup.cpuacct.control_group - the cpuacct control group to which the Elasticsearch process belongs.
          - os.cgroup.cpuacct.usage_nanos - the total CPU time (in nanoseconds) consumed by all tasks in the same cgroup
            as the Elasticsearch process.
          - os.cgroup.cpu.control_group - the cpu control group to which the Elasticsearch process belongs.
          - os.cgroup.cpu.cfs_period_micros - the period of time (in microseconds) for how regularly all tasks in the
            same cgroup as the Elasticsearch process should have their access to CPU resources reallocated.
          - os.cgroup.cpu.cfs_quota_micros - the total amount of time (in microseconds) for which all tasks in the same
            cgroup as the Elasticsearch process can run during one period os.cgroup.cpu.cfs_period_micros.
          - os.cgroup.cpu.stat.number_of_elapsed_periods - the number of reporting periods (as specified by
            os.cgroup.cpu.cfs_period_micros) that have elapsed.
          - os.cgroup.cpu.stat.number_of_times_throttled - the number of times all tasks in the same cgroup as
            the Elasticsearch process have been throttled.
          - os.cgroup.cpu.stat.time_throttled_nanos - the total amount of time (in nanoseconds) for which all tasks in
            the same cgroup as the Elasticsearch process have been throttled.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="os", human=True, level="node"))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="os", human=True, level="node"))
                print()
            except Exception as e:
                print(e)

    def complete_nodes_stats_os(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_process(self, args):
        """
        Show process statistics, memory consumption, cpu usage, open file descriptors.
        $ node_stats_process [node_id/name] - show node ES process stats.
        $ node_stats_process - show ES process stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="process", human=True, level="node"))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="process", human=True, level="node"))
                print()
            except Exception as e:
                print(e)

    def complete_nodes_stats_process(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_thread_pool(self, args):
        """
        Show statistics about each thread pool, including current size, queue and rejected tasks.
        $ node_stats_thread_pool [node_id/name] - show node ES threads stats.
        $ node_stats_thread_pool - show ES threads stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="thread_pool", human=True, level="node"))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="thread_pool", human=True, level="node"))
                print()
            except Exception as e:
                print(e)

    def complete_nodes_stats_thread_pool(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_transport(self, args):
        """
        Show statistics about send and received bytes in cluster communication.
        $ node_stats_transport [node_id/name] - show node ES transport stats.
        $ node_stats_transport - show ES transport stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="transport", human=True, level="node"))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="transport", human=True, level="node"))
                print()
            except Exception as e:
                print(e)

    def complete_nodes_stats_transport(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_breaker(self, args):
        """
        Show statistics about the field data circuit breaker.
        $ node_stats_breaker [node_id/name] - show node ES breaker stats.
        $ node_stats_breaker - show ES transport stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="breaker", human=True, level="node"))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="breaker", human=True, level="node"))
                print()
            except Exception as e:
                print(e)

    def complete_nodes_stats_breaker(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_discovery(self, args):
        """
        Show statistics about the discovery.
        $ node_stats_discovery [node_id/name] - show node ES discovery stats.
        $ node_stats_discovery - show ES discovery stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="discovery", human=True, level="node"))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="discovery", human=True, level="node"))
                print()
            except Exception as e:
                print(e)

    def complete_nodes_stats_discovery(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_ingest(self, args):
        """
        Show statistics about ingest preprocessing.
        $ node_stats_ingest [node_id/name] - show node ES ingest stats.
        $ node_stats_ingest - show ES ingest stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="ingest", human=True, level="node"))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="ingest", human=True, level="node"))
                print()
            except Exception as e:
                print(e)

    def complete_nodes_stats_ingest(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_allocation(self, args):
        """
        Allocation provides a snapshot of how shards have located around the cluster and the state of disk usage.
        $ nodes_allocation [node_id/name] - show node shards allocation.
        $ nodes_allocation - show shards allocation for all the nodes (default).
        """
        if args:
            try:
                print()
                print(es.cat.allocation(node_id=args, v=True))
            except Exception as e:
                print(e)
        else:
            try:
                print()
                print(es.cat.allocation(s="node", v=True))
            except Exception as e:
                print(e)

    def complete_nodes_allocation(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    do_nodes_disk = do_nodes_allocation

    def do_nodes_cat_disk_space(self, args):
        """
        Shows nodes available disk space.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,disk", v=True))
        except Exception as e:
            print(e)

    def do_nodes_fielddata(self, args):
        """
        Shows information about currently loaded fielddata on a per-node basis.
        """
        try:
            print()
            print(es.cat.fielddata(s="node", v=True, bytes="mb"))
        except Exception as e:
            print(e)

    def do_nodes_attributes(self, args):
        """
        Shows custom node attributes.
        """
        try:
            print()
            print(es.cat.nodeattrs(s="node", v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_id(self, args):
        """
        Shows nodes uniq ids.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,id", full_id=True, v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_ports(self, args):
        """
        Shows nodes bound ip, transport and http address.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,port,http_address", v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_version(self, args):
        """
        Shows nodes Elasticsearch version, build hash and running java version.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,version,build,jdk", v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_heap(self, args):
        """
        Shows nodes used and maximum configured heap.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,heap.current,heap.percent,heap.max", v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_ram(self, args):
        """
        Shows nodes used and total memory.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,ram.current,ram.percent,ram.max", v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_filedesc(self, args):
        """
        Shows nodes used and maximum number of file descriptors.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,file_desc.current,file_desc.percent,file_desc.max", v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_load(self, args):
        """
        Shows nodes recent system CPU usage.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,cpu,load_1m,load_5m,load_15m", v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_uptime(self, args):
        """
        Shows nodes uptime.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,uptime", v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_role(self, args):
        """
        Shows nodes role.
        - m - master eligible node.
        - d - data node.
        - i - ingest node.
        - - - coordinating node only.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,node.role,master", v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_completion(self, args):
        """
        Shows nodes size of completion.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,completionSize", v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_fielddata_evictions(self, args):
        """
        Shows used fielddata cache memory and evictions.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,fielddataMemory,fielddataEvictions", v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_query_cache(self, args):
        """
        Shows used query cache memory and evictions.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,queryCacheMemory,queryCacheEvictions", v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_request_cache(self, args):
        """
        Shows used request cache memory, evictions, hit and miss count.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,requestCacheMemory,requestCacheEvictions,requestCacheHitCount,requestCacheMissCount",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_flush(self, args):
        """
        Shows number of flushes and time spent in flush.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,flushTotal,flushTotalTime",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_get(self, args):
        """
        Shows number of current and total get operations, time spent in gets and others .
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,getCurrent,getTime,getTotal,getExistsTime,getExistsTotal,getMissingTime,getMissingTotal",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_delete(self, args):
        """
        Shows number of current and total delete operations, time spent in deletions.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,indexingDeleteCurrent,indexingDeleteTime,indexingDeleteTotal",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_index(self, args):
        """
        Shows number of current and total index operations, time spent in indexing.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,indexingIndexCurrent,indexingIndexTime,indexingIndexTotal,indexingIndexFailed",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_merges(self, args):
        """
        Shows number of current and total mege operations, time spent in merging.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,mergesCurrent,mergesCurrentDocs,mergesCurrentSize,mergesTotal,mergesTotalDocs,mergesTotalSize,mergesTotalTime",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_refresh(self, args):
        """
        Shows number of refreshes and time spent in refreshes.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,refreshTotal,refreshTime",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_script(self, args):
        """
        Shows total script compilations and compiled scripts evicted from cache.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,scriptCompilations,scriptCacheEvictions",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_search(self, args):
        """
        Shows open search contexts.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,searchOpenContexts",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_search_fetch(self, args):
        """
        Shows current fetch phase operations and time spent in fetch phase.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,searchFetchCurrent,searchFetchTime,searchFetchTotal",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_search_query(self, args):
        """
        Shows current query phase operations and time spent in query phase.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,searchQueryCurrent,searchQueryTime,searchQueryTotal",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_search_scroll(self, args):
        """
        Shows current open scroll contexts and time scroll contexts held open.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,searchScrollCurrent,searchScrollTime,searchScrollTotal",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_segments(self, args):
        """
        Shows number of segments and memory used by segments.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,segmentsCount,segmentsMemory,segmentsIndexWriterMemor,segmentsVersionMapMemory,fixedBitsetMemory",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_cat_suggest(self, args):
        """
        Shows number current suggest operations and time spent in suggest.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,suggestCurrent,suggestTime,suggestTotal",
                               v=True))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_bulk(self, args):
        """
        Show current settings and status of threads for bulk operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="bulk", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_generic(self, args):
        """
        Show current settings and status of threads for generic (e.g., background node discovery) operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="generic", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_index(self, args):
        """
        Show current settings and status of threads for index / delete operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="index", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_search(self, args):
        """
        Show current settings and status of threads for count / search / suggest operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="search", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_get(self, args):
        """
        Show current settings and status of threads for get operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="get", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_percolate(self, args):
        """
        Show current settings and status of threads for percolate operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="percolate", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_snapshot(self, args):
        """
        Show current settings and status of threads for snapshot / restore operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="snapshot", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_warmer(self, args):
        """
        Show current settings and status of threads for segment warm-up operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="warmer", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_refresh(self, args):
        """
        Show current settings and status of threads for refresh operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="refresh", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_listener(self, args):
        """
        Show current settings and status of threads for java client executing action operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="listener", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_management(self, args):
        """
        Show current settings and status of threads management operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="management", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_force_merge(self, args):
        """
        Show current settings and status of threads force merge / optimize operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="force_merge", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_flush(self, args):
        """
        Show current settings and status of threads flush operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="flush", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_fetch_shard_started(self, args):
        """
        Show current settings and status of threads starting shard operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="fetch_shard_started", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_thread_pool_fetch_shard_store(self, args):
        """
        Show current settings and status of threads storing shard operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="fetch_shard_store", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception as e:
            print(e)

    def do_nodes_tasks(self, args):
        """
        Show tasks currently executing on one or mode nodes in the cluster.
        $ nodes_tasks [task_id] - show info about particular task.
        $ nodes_tasks - retrieves all tasks currently running on all nodes in the cluster (default).
        """

        if args:
            try:
                print()
                print(json.dumps(es.tasks.get(task_id=args), indent=4))
                print()
            except Exception as e:
                print(e)
        else:
            try:
                print()
                print(es.cat.tasks(v=True, detailed=True, s="node"))
            except Exception as e:
                print(e)


class Exec(cmd.Cmd):
    intro = "{0}\n### Entering to cluster execution menu!\n### For more information, type \"help\" or \"?\".\n{1}". \
        format(BColors.BOLD, BColors.ENDC)
    prompt = "es:exec~$ "
    ruler = "-"
    doc_header = "Available commands (type: help <command>):"

    def default(self, line):
        """
        Called on an input line when the command prefix is not recognized.
        In that case we execute the line as Python code.
        """
        try:
            exec(line) in self._locals, self._globals
        except NameError:
            print("Command {0} not found.".format(line))
        except SyntaxError:
            print("Invalid command syntax.")
        except KeyboardInterrupt:
            print("Detected Ctrl+D. Exiting...")
        except Exception as e:
            print("{0} : {1}".format(e.__class__, e))

    def preloop(self):
        """
        Initialization before prompting user for commands.
        """
        cmd.Cmd.preloop(self)
        self._history = []
        self._locals = {}
        self._globals = {}

    def precmd(self, line):
        """
        This method is called after the line has been input but before
        it has been interpreted. If you want to modifdy the input line
        before execution (for example, variable substitution) do it here.
        """
        self._history += [line.strip()]
        return line

    def postloop(self):
        """
        Take care of any unfinished business.
        """
        cmd.Cmd.postloop(self)
        print("Exiting...")

    def postcmd(self, stop, line):
        """
        If you want to stop the console, return something that evaluates to true.
        If you want to do some post command processing, do it here.
        """
        return stop

    def emptyline(self):
        """
        Do nothing on empty line input.
        """
        pass

    def do_prompt(self, args):
        """
        Change console prompt.
        $ prompt [new prompt] - set new prompt.
        """
        self.prompt = "{0}:~$ ".format(args)

    def do_help(self, args):
        """
        Get help on commands:
        'help' or '?' with no arguments prints a list of commands for which help is available
        'help <command>' or '? <command>' gives help on <command>
        """
        cmd.Cmd.do_help(self, args)

    def do_history(self, args):
        """
        Print a list of commands that have been entered into console.
        """
        print(self._history)

    def do_clear(self, args):
        """
        Clear the screen.
        """
        os.system("clear")

    def do_shell(self, line):
        """
        Pass command to a system shell when line begins with '!'
        """
        print("Running shell command: {0}\n".format(line))
        sub_cmd = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE)
        output = sub_cmd.communicate()[0].decode("utf-8")
        print(output)
        self.last_output = output

    def do_echo(self, line):
        """
        Print the input, replacing '$out' with the output of the last shell command.
        """
        print(line.replace("$out", self.last_output))

    def do_quit(self, args):
        """
        Quits from the console.
        """
        print("Quitting...")
        sys.exit(0)

    def do_exit(self, args):
        """
        Exits from the console.
        """
        print("Exiting...")
        sys.exit(0)

    def do_EOF(self, line):
        """
        Exit on system end of file character (Ctrl+D).
        """
        return True

    def do_show(self, line):
        """Execute command in cluster information menu."""
        Show().onecmd(line)

    def complete_show(self, text, line, begidx, endidx):
        return [i for i in commandlist(Show()) if i.startswith(text)]

    def do_cluster_settings_transient(self, args):
        """
        Update cluster wide specific settings.
        Resetting transient settings can be done by assigning a 'null' value.
        $ cluster_settings_transient script.max_compilations_per_minute 100
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter setting and its value.")
                print()
            else:
                try:
                    setme = '{{ "transient": {{ "{0}" : {1} }} }}'.format(str(parms[0]), str(parms[1]))
                    print()
                    print("Setting: " + setme)
                    print()
                    es.cluster.put_settings(body=setme, flat_settings=True, timeout="300s")
                except Exception as e:
                    print(e)
        else:
            try:
                print()
                print("Please enter setting and its value.")
                print()
            except Exception as e:
                print(e)

    def do_cluster_settings_persistent(self, args):
        """
        Update cluster wide specific settings.
        Resetting persistent settings can be done by assigning a 'null' value.
        $ cluster_settings_persistent script.max_compilations_per_minute 100
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter setting and its value.")
                print()
            else:
                try:
                    setme = '{{ "persistent": {{ "{0}" : {1} }} }}'.format(str(parms[0]), str(parms[1]))
                    print()
                    print("Setting: " + setme)
                    print()
                    es.cluster.put_settings(body=setme, flat_settings=True, timeout="300s")
                except Exception as e:
                    print(e)
        else:
            try:
                print()
                print("Please enter setting and its value.")
                print()
            except Exception as e:
                print(e)

    def do_indices_forcemerge(self, args):
        """
        The force merge API allows to force merging of one or more indices through an API.
        The merge relates to the number of segments a Lucene index holds within each shard.
        The force merge operation allows to reduce the number of segments by merging them.
        $ indices_forcemerge [index name] [number of segments] - merge index to X segments.
        """
        parms = args.split()
        if len(parms) != 2:
            print()
            print("Invalid number of arguments. Please provide index name nad number of segments.")
            print()
        else:
            try:
                es.indices.forcemerge(index=parms[0], max_num_segments=parms[1])
            except Exception as e:
                print(e)

    def complete_indices_forcemerge(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_delete(self, args):
        """
        Delete an index in Elasticsearch.
        $ indices_delete [index name] - delete the specified index.
        """
        if args:
            try:
                es.indices.delete(index=args, master_timeout="300s")
            except Exception as e:
                print(e)
        else:
            print()
            print("Missing index or a comma-separated list of indices to delete.")
            print()

    def complete_indices_delete(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_close(self, args):
        """
        Close an index to remove it's overhead from the cluster.
        Closed index is blocked for read/write operations.
        $ indices_close [index name] - close the specified index.
        """
        if args:
            try:
                es.indices.close(index=args, master_timeout="300s")
            except Exception as e:
                print(e)
        else:
            print()
            print("Missing index or a comma-separated list of indices to close.")
            print()

    def complete_indices_close(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_open(self, args):
        """
        Open a closed index to make it available for search.
        $ indices_open [index name] - open the specified index.
        """
        if args:
            try:
                es.indices.open(index=args, master_timeout="300s")
            except Exception as e:
                print(e)
        else:
            print()
            print("Missing index or a comma-separated list of indices to open.")
            print()

    def complete_indices_open(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache(self, args):
        """
        Clear either all caches or specific cached associated with one or more indices.
        $ indices_clear_cache  [index name ] - clear cache of the specified index.
        $ indices_clear_cache - clear all caches (default)
        """
        if args:
            try:
                es.indices.clear_cache(index=args)
            except Exception as e:
                print(e)
        else:
            try:
                es.indices.clear_cache()
            except Exception as e:
                print(e)

    def complete_indices_clear_cache(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache_fielddata(self, args):
        """
        Clear field data.
        $ indices_clear_cache_fielddata [ index name ] - clear field data of the specified index.
        $ indices_clear_cache_fielddata - clear field data of all indices (default).
        """
        if args:
            try:
                es.indices.clear_cache(index=args, fielddata=True)
            except Exception as e:
                print(e)
        else:
            try:
                es.indices.clear_cache(fielddata=True)
            except Exception as e:
                print(e)

    def complete_indices_clear_cache_fielddata(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache_query(self, args):
        """
        Clear query caches.
        $ indices_clear_cache_query [ index name ] - clear query caches of the specified index.
        $ indices_clear_cache_query - clear query caches of all indices (default).
        """
        if args:
            try:
                es.indices.clear_cache(index=args, query=True)
            except Exception as e:
                print(e)
        else:
            try:
                es.indices.clear_cache(query=True)
            except Exception as e:
                print(e)

    def complete_indices_clear_cache_query(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache_recycler(self, args):
        """
        Clear the recycler cache.
        $ indices_clear_cache_recycler [ index name ] - clear the recycler cache of the specified index.
        $ indices_clear_cache_recycler - clear the recycler cache of all indices (default).
        """
        if args:
            try:
                es.indices.clear_cache(index=args, recycler=True)
            except Exception as e:
                print(e)
        else:
            try:
                es.indices.clear_cache(recycler=True)
            except Exception as e:
                print(e)

    def complete_indices_clear_cache_recycler(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache_request(self, args):
        """
        Clear the request cache.
        $ indices_clear_cache_request [ index name ] - clear the request cache of the specified index.
        $ indices_clear_cache request - clear the request cache of all indices (default).
        """
        if args:
            try:
                es.indices.clear_cache(index=args, request=True)
            except Exception as e:
                print(e)
        else:
            try:
                es.indices.clear_cache(request=True)
            except Exception as e:
                print(e)

    def complete_indices_clear_cache_request(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_move_dry_run(self, args):
        """
        Simulate move started shard from one node to another node.  Accepts 'index' for index name and
        'shard number', 'from_node' for the node to move the shard from, and 'to_node' for the node to
        move the shard to.
        $ shards_move_dry_run .kibana 0 node1 node2 - simulate move shard 0 of index .kibana from node1 to node2.
        """
        if args:
            parms = args.split()
            if len(parms) != 4:
                print()
                print("Invalid number of arguments. Please enter index_name shard_number from_node to_node.")
                print()
            else:
                try:
                    moveme = '{{ "commands": [ {{ "move": {{ "index": "{0}", "shard": {1}, "from_node": "{2}",' \
                             '"to_node": "{3}" }} }} ] }}'.format(str(parms[0]), str(parms[1]), str(parms[2]),
                                                                  str(parms[3]))
                    print()
                    print("Executing: " + moveme)
                    print()
                    pretty_print(es.cluster.reroute(body=moveme, dry_run=True, explain=True, metric="master_node"),
                                 indent=2)
                    print()
                except Exception as e:
                    print(e)
        else:
            try:
                print()
                print("Please enter index_name shard_number from_node to_node.")
                print()
            except Exception as e:
                print(e)

    def complete_shards_move_dry_run(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_move(self, args):
        """
        Move started shard from one node to another node.  Accepts 'index' for index name and
        'shard number', 'from_node' for the node to move the shard from, and 'to_node' for the
        node to move the shard to.
        $ shards_move .kibana 0 node1 node2 - move shard 0 of index .kibana from node1 to node2.
        """
        if args:
            parms = args.split()
            if len(parms) != 4:
                print()
                print("Invalid number of arguments. Please enter index_name shard_number from_node to_node.")
                print()
            else:
                try:
                    moveme = '{{ "commands": [ {{ "move": {{ "index": "{0}", "shard": {1}, "from_node": "{2}",' \
                             '"to_node": "{3}" }} }} ] }}'.format(str(parms[0]), str(parms[1]), str(parms[2]),
                                                                  str(parms[3]))
                    print()
                    print("Executing: " + moveme)
                    print()
                    pretty_print(es.cluster.reroute(body=moveme, explain=True, metric="master_node"), indent=2)
                    print()
                except Exception as e:
                    print(e)
        else:
            try:
                print()
                print("Please enter index_name shard_number from_node to_node.")
                print()
            except Exception as e:
                print(e)

    def complete_shards_move(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("No elasticsearch server specified. Using default localhost.{0}".format(BColors.ENDC))
        if isopen("127.0.0.1", 9200):
            host = "127.0.0.1"
        else:
            sys.exit(2)
    elif len(sys.argv) == 2:
        if check_hostname(sys.argv[1]):
            print(BColors.HEADER + "Connecting to elasticsearch server at address: {0:s}".format(sys.argv[1]) +
                  BColors.ENDC)
            if isopen(sys.argv[1], 9200):
                host = sys.argv[1]
            else:
                sys.exit(2)
        elif check_ip(sys.argv[1]):
            print(BColors.HEADER + "Connecting to elasticsearch server at address: {0:s}".format(sys.argv[1]) +
                  BColors.ENDC)
            if isopen(sys.argv[1], 9200):
                host = sys.argv[1]
            else:
                sys.exit(2)
        else:
            print("Wrong DNS or IP elasticsearch node address.")
    else:
        sys.exit("Usage: {0} [ES master IP/DNS address]".format(sys.argv[0]))
    try:
        if "libedit" in readline.__doc__:
            readline.parse_and_bind("bind ^I rl_complete")
        else:
            readline.parse_and_bind("tab: complete")
        if "ESAUTH" in os.environ:
            host = "http://{0}@{1}:9200".format(os.environ["ESAUTH"], host)
        else:
            host = "http://{0}:9200".format(host)
        es = elasticsearch.Elasticsearch([host], sniff_on_start=False, sniff_on_connection_fail=False,
                                         sniffer_timeout=None, timeout=300, retry_on_timeout=True, retry_on_status=True,
                                         max_retries=3)
        esconsole = ES()
        esconsole.cmdloop()
    except KeyboardInterrupt:
        error("Exiting...")
    except Exception as e:
        print(e)
